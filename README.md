# TARG-Compiler

Note: This project was given as an assignment in the Data Structures and Algorithms course at IIT Delhi.

## Overview
Targ-Compiler is a compiler for the TARG programming language, which is a simple imperative language designed for educational purposes. The compiler translates TARG code into assembly language for a hypothetical stack-based machine. 

#### Assumptions for the stack machine:
 - An infinite memory, with operations providing access to only the top element(s). It is used to
store temporary values in the evaluation of expressions.
 - Access to a limited indexable (random-access) memory

 Essentially, the machine will go through the program in the target language Targ, perform some operations
on the operands in the stack, and finally store the results in the memory


---

## Command Syntax

The following table describes the primary commands in the Targ language:

| Command | Description |
|------|------------|
| `PUSH x` | Pushes a literal integer `x` onto the stack. |
| `PUSH mem[i]` | Pushes the value currently in the *i<sup>th</sup>* memory location onto the stack. |
| `mem[i] = POP` | Pops the top value from the stack and stores it in the *i<sup>th</sup>* memory location. |
| `DEL mem[i]` | Deletes the value at the *i<sup>th</sup>* memory location and frees it for future use. |
| `ADD` | Pops the top two elements, adds them, and pushes the result back onto the stack. |
| `SUB` | Pops the top two elements; subtracts the second-from-top from the top element and pushes the result. |
| `MUL` | Pops two elements, multiplies them, and pushes the result. |
| `DIV` | Pops two elements, performs floor division *(top / second-from-top)*, and pushes the result. |
| `RET = POP` | Pops the top value into a special `ret` memory location and terminates the program. |

---

## Operational Logic

### Error Handling
- If a division by zero is attempted, the result is set to `NULL`.

### NULL Propagation
- Any arithmetic operation performed with `NULL` as an operand results in `NULL`.

### Execution
- The machine processes the generated Targ file **line-by-line** in a **sequential** manner.


## Overview of the Compiler Structure
The file structure of the compiler is as follows:

.
├── README.md
├── avlgen.py
├── bin
│   ├── e++
│   ├── error.log
│   ├── targ.txt
│   └── tester
├── error.log
├── include
│   ├── eppcompiler
│   ├── eppcompiler.h
│   ├── exprtreenode.h
│   ├── heapnode.h
│   ├── minheap.h
│   ├── parser.h
│   ├── symnode.h
│   ├── symtable.h
│   ├── ulimitedint.h
│   └── ulimitedrational.h
├── makefile
├── samples
│   ├── e++_correct.txt
│   ├── e++_wrong.txt
│   ├── targ_correct.txt
│   └── targ_wrong.txt
├── src
│   ├── eppcompiler
│   ├── eppcompiler.cpp
│   ├── exprtreenode.cpp
│   ├── heapnode.cpp
│   ├── minheap.cpp
│   ├── output2.txt
│   ├── parser.cpp
│   ├── symnode.cpp
│   ├── symtable.cpp
│   ├── ulimitedint.cpp
│   └── ulimitedrational.cpp
├── targ.txt
└── tests
    ├── linker
    ├── main.cpp
    └── targ

The main components of the compiler are:


## Parser Module

This module implements the `Parser` class, which converts tokenized E++ statements into **expression trees** suitable for further compilation into Targ instructions.

- Parses assignment (`:=`), return (`ret`), and delete (`del`) statements.
- Constructs an `ExprTreeNode`–based abstract syntax tree (AST) for each expression.
- Handles arithmetic expressions with parentheses and operators (`+`, `-`, `*`, `/`) using a stack-based tree construction.
- Differentiates between variables and literal values, resolving variable indices through a symbol table.
- Stores all generated expression trees in an internal list for later processing.


---
## ExprTreeNode Implementation

This file implements the constructors and destructor for `ExprTreeNode`.  
It initializes expression tree nodes with appropriate types and values, and provides basic cleanup during destruction.  
These nodes form the building blocks of the abstract syntax tree generated by the parser.


---
## UnlimitedInt Implementation

This module implements arbitrary-precision integers with support for signed values.  
It provides core arithmetic operations—addition, subtraction, multiplication, division, and modulus—implemented directly on digit arrays.  
`UnlimitedInt` serves as the numerical backbone for higher-level rational arithmetic in the compiler.


---
## UnlimitedRational Implementation

This module implements arbitrary-precision rational numbers using `UnlimitedInt` for the numerator and denominator.  
It supports normalization via GCD, sign handling, and basic arithmetic operations (addition, subtraction, multiplication, and division).  
All rational values are stored in reduced form.


---

## SymNode Implementation

This module defines the node structure used in the AVL-based `SymbolTable`.  
Each `SymNode` stores a variable key, its memory address, height information, and pointers to parent and children.  
It also implements all four AVL tree rotations required to maintain balance.


---

## SymbolTable Implementation

This module implements a symbol table using a self-balancing AVL tree.  
It supports insertion, deletion, lookup, and address assignment for variables while maintaining logarithmic time complexity through rotations.  
The symbol table is used by the parser and compiler to map variable identifiers to memory locations.

---

## Samples
The `samples` directory contains example Targ and E++ programs, both correct and incorrect, to test the compiler's functionality and error handling.

## tests
The `tests` directory contains the test harness and main driver code to compile and run Targ programs using the implemented compiler.



